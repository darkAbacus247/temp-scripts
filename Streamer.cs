using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine.SceneManagement;
#if AT_STREAMER2
using Atavism;
#endif

namespace WorldStreamer2{
#if AT_STREAMER2
    public class Streamer : AtavismStreamer
#else
    public class Streamer : MonoBehaviour
#endif
    {
        [Tooltip("This checkbox deactivates streamer and unload or doesn't load it's data.")]
        public bool streamerActive = true;

        public static string STREAMERTAG = "SceneStreamer";
        // [HideInInspector]
        [Tooltip("Drag and drop here your scene collection prefab. You could find it in catalogue with scenes which were generated by scene splitter.")]

        public List<SceneCollectionManager> sceneCollectionManagers;

        [Header("Settings")]
        [Tooltip("Frequancy in seconds in which you want to check if grid element is close /far enough to load/unload.")]

        public float positionCheckTime = 0.1f;
        [Tooltip("Time in seconds after which grid element will be unloaded.")]

        public float destroyTileDelay = 2;

        [Tooltip("Number of empty frames between loading actions.")]

        public int sceneLoadWaitFrames = 2;

        [Space(10)]
        [Tooltip("If you want to fix small holes from LODs system at unity terrain borders, drag and drop object here from scene hierarchy that contains our \"Terrain Neighbours\" script.")]

        public TerrainNeighbours terrainNeighbours;


        [Space(10)]
        [Tooltip("Enable looping system, each layer is streamed independently, so if you want to synchronize them, they should have the same XYZ size. More info at manual.")]

        public bool looping = false;
        public bool overideRangeLimit = true;
        public bool overideScenesLimits = true;

        [Space(10)]
        [Header("Player Settings")]
        [Tooltip("Drag and drop here, an object that system have to follow during streaming process.")]

        [SerializeField]
        private Transform _player;

        public Transform player
        {
            get
            {
                if (spawnedPlayer && _player == null && !string.IsNullOrEmpty(playerTag))
                {
                    GameObject playerGO = GameObject.FindGameObjectWithTag(playerTag);
                    if (playerGO != null)
                        _player = playerGO.transform;
                }
                return _player;
            }
            set => _player = value;
        }

        [Tooltip("Streamer will wait for player spawn and fill it automatically")]

        public bool spawnedPlayer;

        [HideInInspector]
        public string playerTag = "Player";

        [HideInInspector]

        public bool showLoadingScreen = true;


        [HideInInspector]

        public UILoadingStreamer loadingStreamer;

        [HideInInspector]
        public bool initialized = false;

        [HideInInspector]

        public int tilesToLoad = int.MaxValue;

        [HideInInspector]

        public int tilesLoaded;

        public float LoadingProgress
        {
            get { return (tilesToLoad > 0) ? tilesLoaded / (float)tilesToLoad : 1; }
        }


        [HideInInspector]
        public WorldMover
            worldMover;

        [HideInInspector]

        public Vector3 currentMove = Vector3.zero;

        List<SceneSplit> scenesToLoad = new List<SceneSplit>();

        int sceneLoadFrameNext = 0;

        bool sceneLoadFramesNextWaited = false;

        public StreamerLoadingManager loadingManager;

        static bool canUnload = true;
        static float waitTillNextUnload = 20;
        static bool unloadNext = false;


        void Awake()
        {
            //if (spawnedPlayer)
            //{
            //    player = null;
            //}
#if AT_STREAMER2
            if (ClientAPI.GetPlayerObject() != null)
            {
                GameObject go = ClientAPI.GetPlayerObject().GameObject;
                if (go != null)
                    player = go.transform;
            }
#endif
            foreach (var sceneCollectionManager in sceneCollectionManagers)
            {
                sceneCollectionManager.ResetPosition();
            }
        }


        void Start()
        {
            loadingManager = new StreamerLoadingManager() { streamer = this };



            if (sceneCollectionManagers != null && sceneCollectionManagers.Count > 0)
            {

                PrepareScenesArray();

                StartCoroutine(PositionChecker());
                canUnload = true;
            }
            else
            {
                enabled = false;
                Debug.LogError("No scene collection in streamer");
            }

        }

        #region prepare scene


        void PrepareScenesArray()
        {
            Vector2Int xLimits = Vector2Int.zero;
            Vector2Int yLimits = Vector2Int.zero;
            Vector2Int zLimits = Vector2Int.zero;

            if (sceneCollectionManagers.Count > 1)
            {
                sceneCollectionManagers[0].GetSceneCollectionWolrdLimits(out xLimits, out yLimits, out zLimits);
                Debug.Log(xLimits + " " + yLimits + " " + zLimits);
            }
            foreach (var sceneCollectionManager in sceneCollectionManagers)
            {
                sceneCollectionManager.unloadRangeConnectParent = null;
            }
            foreach (var sceneCollectionManager in sceneCollectionManagers)
            {
                if (sceneCollectionManager.useUnloadRangeConnect && sceneCollectionManager.unloadRangeConnect != null)
                {
                    sceneCollectionManager.unloadRangeConnect.unloadRangeConnectParent = sceneCollectionManager;
                }

                if (overideScenesLimits && sceneCollectionManagers.Count > 1)
                {
                    sceneCollectionManager.CalculateLoadingLimits(looping, overideRangeLimit, overideScenesLimits, xLimits, yLimits, zLimits);
                    sceneCollectionManager.PrepareScenesArray(overideRangeLimit, overideScenesLimits, xLimits, yLimits, zLimits);
                }
                else
                {

                    sceneCollectionManager.CalculateLoadingLimits(looping, overideRangeLimit);
                    sceneCollectionManager.PrepareScenesArray(overideRangeLimit);
                }
            }
        }


        /// <param name="sceneName">Scene name.</param>
        /// <param name="posX">Position x.</param>
        /// <param name="posY">Position y.</param>
        /// <param name="posZ">Position z.</param>
        public static void SceneNameToPos(SceneCollectionManager sceneCollectionManager, string sceneName, out int posX, out int posY, out int posZ)
        {
            posX = 0;
            posY = 0;
            posZ = 0;

            string[] values = sceneName.Replace(sceneCollectionManager.prefixScene, "").Replace(".unity", "").Split(new char[] {
            '_'
        }, System.StringSplitOptions.RemoveEmptyEntries);

            foreach (var item in values)
            {
                if (item[0] == 'x')
                {
                    posX = int.Parse(item.Replace("x", ""));
                }
                if (item[0] == 'y')
                {
                    posY = int.Parse(item.Replace("y", ""));
                }
                if (item[0] == 'z')
                {
                    posZ = int.Parse(item.Replace("z", ""));
                }
            }

        }


        #endregion

        public static int mod(int x, int m)
        {
            return (x % m + m) % m;
        }

        #region scene loading
        // Called second
        public void OnSceneLoaded(Scene scene, SceneSplit split)
        {
            GameObject[] rootGameObjects = scene.GetRootGameObjects();

            if (rootGameObjects.Length > 0)
            {
                AddSceneGOMin(split, rootGameObjects[0]);
            }
        }

        public void AddSceneGOMin(SceneSplit split, GameObject sceneGO)
        {
            SceneCollectionManager manager = split.sceneCollectionManager;

            // Get position coordinates
            int posX, posY, posZ;
            SceneNameToPos(manager, split.sceneName, out posX, out posY, out posZ);
            Vector3Int posInt = new Vector3Int(posX, posY, posZ);

            tilesLoaded++;

            // Calculate position offset
            Vector3 posOffset = new Vector3(manager.xSize * (split.posX - posInt.x),
                                            manager.ySize * (split.posY - posInt.y),
                                            manager.zSize * (split.posZ - posInt.z)) +
                                currentMove + new Vector3(split.posXLimitMove, split.posYLimitMove, split.posZLimitMove);

            // Update split properties
            split.sceneGo = sceneGO;
            split.scene = sceneGO.scene;
            split.loadingFinished = true;

            manager.currentlySceneLoading--;
            sceneGO.transform.position = posOffset;

            // Unload scenes if needed
            SceneCollectionManager unloadManager = null;
            if (manager.useUnloadRangeConnect && manager.unloadRangeConnect != null)
            {
                unloadManager = manager.unloadRangeConnect;
            }
            if (manager.unloadRangeConnectParent != null && manager.unloadRangeConnectParent.useUnloadRangeConnect)
            {
                unloadManager = manager.unloadRangeConnectParent;
            }

            if (unloadManager != null)
            {
                UnloadOverlappingScenes(split, posOffset, unloadManager);
            }
        }

        private void UnloadOverlappingScenes(SceneSplit split, Vector3 posOffset, SceneCollectionManager unloadManager)
        {
            SceneSplit splitToCheck;
            float count = unloadManager.loadedScenes.Count;

            for (int i = 0; i < count; i++)
            {
                splitToCheck = unloadManager.loadedScenes[i];

                if (splitToCheck.loadingFinished)
                {
                    if (split.basePosX == splitToCheck.basePosX && split.basePosY == splitToCheck.basePosY && split.basePosZ == splitToCheck.basePosZ)
                    {
                        if (posOffset == splitToCheck.sceneGo.transform.position)
                        {
                            UnloadScenesSync(splitToCheck);
                            break;
                        }
                    }
                }
            }
        }

        #endregion

        #region Update Functions

        /// <summary>
        /// Update this instance, starts load level async
        /// </summary>
        private void Update()
        {
            ManageAsyncSceneLoading();
            loadingManager.Update();
        }

        /// <summary>
        /// Manages async scene loading
        /// </summary>
        private void ManageAsyncSceneLoading()
        {
            if (scenesToLoad.Count <= 0) return;

            if (LoadingProgress < 1 || sceneLoadFramesNextWaited && sceneLoadFrameNext <= 0)
            {
                sceneLoadFramesNextWaited = false;
                sceneLoadFrameNext = sceneLoadWaitFrames;
                scenesToLoad = scenesToLoad.OrderBy(x => x.sceneCollectionManager.priority).ToList();

                for (int i = 0; i < scenesToLoad.Count;)
                {
                    SceneSplit split = scenesToLoad[i];

                    if (split.sceneCollectionManager.currentlySceneLoading < split.sceneCollectionManager.maxParallelSceneLoading)
                    {
                        scenesToLoad.RemoveAt(i);
                        split.sceneCollectionManager.currentlySceneLoading++;
                        loadingManager.LoadSceneAsync(split);
                    }
                    else
                    {
                        i++;
                    }
                }
            }
            else
            {
                sceneLoadFramesNextWaited = true;
                sceneLoadFrameNext--;
            }
        }


        /// <summary>
        /// Coroutine checks player position
        /// </summary>
        /// <returns>The checker.</returns>
        private IEnumerator PositionChecker()
        {
            while (true)
            {
                if (spawnedPlayer && player == null && !string.IsNullOrEmpty(playerTag))
                {
                    GameObject playerGO = GameObject.FindGameObjectWithTag(playerTag);
#if AT_STREAMER2
                    if(ClientAPI.GetPlayerObject() != null && playerGO==null)
                        playerGO =  ClientAPI.GetPlayerObject().GameObject; 
#endif
                    if (playerGO != null)
                        player = playerGO.transform;
                }

                if (streamerActive && player != null)
                {
                    CheckPositionTiles();
                }
                else
                {
#if !AT_STREAMER2
                    bool loadedScenes = false;

                    foreach (var sceneCollectionManager in sceneCollectionManagers)
                    {
                        if (sceneCollectionManager.loadedScenes.Count > 0)
                        {
                            loadedScenes = true;
                            sceneCollectionManager.ResetPosition();
                        }
                    }
                    if (loadedScenes)
                        UnloadAllScenes();
#endif
                }

                yield return new WaitForSeconds(positionCheckTime);
            }
        }

        /// <summary>
        /// Checks the position of player in tiles.
        /// </summary>
        public void CheckPositionTiles()
        {
            Vector3 pos = player.position;

            pos -= currentMove;

            bool changed = false;

            foreach (var sceneCollectionManager in sceneCollectionManagers)
            {
                if (sceneCollectionManager.CheckPosition(pos))
                    changed = true;
            }

            if (changed)
            {
                SceneLoading();
                Invoke("SceneUnloading", destroyTileDelay);

                if (worldMover != null)
                {
                    worldMover.CheckMoverDistance(sceneCollectionManagers[0].xPos, sceneCollectionManagers[0].yPos, sceneCollectionManagers[0].zPos);
                }
            }
        }


        #endregion

        #region loading and unloading

        void SceneLoading()
        {
            if (showLoadingScreen && loadingStreamer != null)
            {
                showLoadingScreen = false;
                if (tilesLoaded >= tilesToLoad)
                {
                    tilesToLoad = int.MaxValue;
                    tilesLoaded = 0;
                }
            }

            int tilesToLoadNew = 0;

            foreach (var scm in sceneCollectionManagers)
            {
                if (!scm.active)
                {
                    continue;
                }

                int x = scm.xPos;
                int y = scm.yPos;
                int z = scm.zPos;

                int LoadingRangeX = (int)scm.loadingRange.x * 2 + 1;
                int LoadingRangeZ = (int)scm.loadingRange.z * 2 + 1;
                int xs = 0, zs = 0, dx = 0, dy = -1;
                int t = Math.Max(LoadingRangeX, LoadingRangeZ);
                int maxI = t * t;

                SceneSplit split;
                for (int i = 0; i < maxI; i++)
                {
                    if ((-LoadingRangeX / 2 <= xs) && (xs <= LoadingRangeX / 2) && (-LoadingRangeZ / 2 <= zs) && (zs <= LoadingRangeZ / 2))
                    {
                        for (int ys = 0; ys <= scm.loadingRange.y; ys++)
                        {
                            for (int yi = -1; yi <= 1; yi += 2)
                            {
                                if (ys == 0 && yi != -1)
                                    continue;

                                if (scm.useLoadingRangeMin)
                                    if (xs >= -scm.loadingRangeMin.x && xs <= scm.loadingRangeMin.x &&
                                        ys >= -scm.loadingRangeMin.y && ys <= scm.loadingRangeMin.y &&
                                        zs >= -scm.loadingRangeMin.z && zs <= scm.loadingRangeMin.z)
                                    {
                                        continue;
                                    }

                                x = xs + scm.xPos;
                                y = ys * yi + scm.yPos;
                                z = zs + scm.zPos;

                                Vector3Int sceneID = new Vector3Int(x, y, z);

                                float xMoveLimit = 0;
                                int xDeloadLimit = 0;

                                float yMoveLimit = 0;
                                int yDeloadLimit = 0;

                                float zMoveLimit = 0;
                                int zDeloadLimit = 0;

                                if (looping)
                                {
                                    if (scm.xSplitIs)
                                    {
                                        int xFinal = mod((x + Mathf.Abs(scm.xLoadingLimitx)), scm.xLoadingRange) + scm.xLoadingLimitx;

                                        xDeloadLimit = (int)Math.Ceiling((x - scm.xLoadingLimity) / (float)scm.xLoadingRange) * scm.xLoadingRange;
                                        xMoveLimit = xDeloadLimit * scm.xSize;

                                        sceneID[0] = xFinal;
                                    }

                                    if (scm.ySplitIs)
                                    {
                                        int yFinal = mod((y + Mathf.Abs(scm.yLoadingLimitx)), scm.yLoadingRange) + scm.yLoadingLimitx;

                                        yDeloadLimit = (int)Math.Ceiling((y - scm.yLoadingLimity) / (float)scm.yLoadingRange) * scm.yLoadingRange;
                                        yMoveLimit = yDeloadLimit * scm.ySize;
                                        sceneID[1] = yFinal;
                                    }

                                    if (scm.zSplitIs)
                                    {
                                        int zFinal = mod((z + Mathf.Abs(scm.zLoadingLimitx)), scm.zLoadingRange) + scm.zLoadingLimitx;

                                        zDeloadLimit = (int)Math.Ceiling((z - scm.zLoadingLimity) / (float)scm.zLoadingRange) * scm.zLoadingRange;
                                        zMoveLimit = zDeloadLimit * scm.zSize;
                                        sceneID[2] = zFinal;
                                    }
                                }

                                if (scm.scenesArray.TryGetValue(sceneID, out split))
                                {
                                    if (!split.loaded)
                                    {
                                        split.loaded = true;

                                        split.posXLimitMove = xMoveLimit;
                                        split.xDeloadLimit = xDeloadLimit;

                                        split.posYLimitMove = yMoveLimit;
                                        split.yDeloadLimit = yDeloadLimit;

                                        split.posZLimitMove = zMoveLimit;
                                        split.zDeloadLimit = zDeloadLimit;

                                        scenesToLoad.Add(split);
                                        scm.loadedScenes.Add(split);
                                        tilesToLoadNew++;
                                    }
                                }
                            }
                        }
                    }

                    if ((xs == zs) || ((xs < 0) && (xs == -zs)) || ((xs > 0) && (xs == 1 - zs)))
                    {
                        t = dx; dx = -dy; dy = t;
                    }
                    xs += dx; zs += dy;
                }
            }

            tilesToLoad = tilesToLoadNew;

            initialized = true;
        }

        void SceneUnloading()
        {
            List<SceneSplit> scenesToDestroy = new List<SceneSplit>(); SceneSplit splitCheck;

            foreach (var scm in sceneCollectionManagers)
            {
                for (int i = 0; i < scm.loadedScenes.Count; i++)
                {
                    splitCheck = scm.loadedScenes[i];
                    if (scm.active)
                    {
                        if (scm.unloadRangeConnectParent == null)
                        {
                            if (Mathf.Abs(splitCheck.posX + splitCheck.xDeloadLimit - scm.xPos) > (int)scm.deloadingRange.x
                                || Mathf.Abs(splitCheck.posY + splitCheck.yDeloadLimit - scm.yPos) > (int)scm.deloadingRange.y
                                || Mathf.Abs(splitCheck.posZ + splitCheck.zDeloadLimit - scm.zPos) > (int)scm.deloadingRange.z)
                                if (splitCheck.sceneGo != null)
                                {
                                    scenesToDestroy.Add(splitCheck);
                                }

                            if (scm.useLoadingRangeMin && !scm.useUnloadRangeConnect)
                                if (Mathf.Abs(splitCheck.posX + splitCheck.xDeloadLimit - scm.xPos) <= scm.loadingRangeMin.x &&
                                    Mathf.Abs(splitCheck.posY + splitCheck.yDeloadLimit - scm.yPos) <= scm.loadingRangeMin.y &&
                                    Mathf.Abs(splitCheck.posZ + splitCheck.zDeloadLimit - scm.zPos) <= scm.loadingRangeMin.z)
                                    if (splitCheck.sceneGo != null)
                                    {
                                        scenesToDestroy.Add(splitCheck);
                                    }
                        }
                    }
                    else
                    {
                        scenesToDestroy.Add(splitCheck);
                    }
                }
            }

            UnloadScenes(scenesToDestroy);
            scenesToDestroy.Clear();

            Streamer.UnloadAssets(this);
        }

        private void UnloadScenesSync(SceneSplit item)
        {
            if (item.sceneGo != null)
            {
                Terrain childTerrain = item.sceneGo.GetComponentInChildren<Terrain>();
                if (childTerrain)
                {
                    GameObject childTerrainGO = childTerrain.gameObject; Destroy(childTerrain);
                    childTerrain = null;
                    Destroy(childTerrainGO);
                    childTerrainGO = null;
                }
            }
            item.loaded = false;
            item.loadingFinished = false;
            item.sceneCollectionManager.loadedScenes.Remove(item);
            item.sceneGo = null;

            loadingManager.UnloadSceneAsync(item.scene);
        }

        private void UnloadScenes(List<SceneSplit> scenesToDestroy)
        {
            foreach (var item in scenesToDestroy)
            {
                item.loaded = false;
                item.loadingFinished = false;
                item.sceneCollectionManager.loadedScenes.Remove(item);
                item.sceneGo = null; loadingManager.UnloadSceneAsync(item.scene);
            }

            if (terrainNeighbours)
                terrainNeighbours.CreateNeighbours();
        }

        public void UnloadAllScenes()
        {
            Debug.Log("UnloadAllScenes start"); foreach (var sceneCollectionManager in sceneCollectionManagers)
            {
                foreach (var item in sceneCollectionManager.scenesArray)
                {
                    if (item.Value.sceneGo != null)
                    {
                        try
                        {
                            loadingManager.UnloadSceneAsync(item.Value.scene);
                        }
                        catch (System.Exception ex)
                        {
                            Debug.Log(item.Value.sceneName);
                            Debug.Log(item.Value.sceneGo.name);
                            Debug.Log(item.Value.sceneGo.scene.name);
                            Debug.LogError(ex.Message);
                        }
                    }

                    item.Value.loaded = false;
                    item.Value.loadingFinished = false;
                    item.Value.sceneGo = null;
                }
                sceneCollectionManager.loadedScenes.Clear();
            }

            if (terrainNeighbours)
                terrainNeighbours.CreateNeighbours();

            Streamer.UnloadAssets(this);
            Debug.Log("UnloadAllScenes finish");
        }

        public static void UnloadAssets(Streamer streamer)
        {
            if (Streamer.canUnload)
            {
                Streamer.canUnload = false;
                streamer.StartCoroutine(streamer.UnloadAssetsWait());
            }
            else
            {
                unloadNext = true;
            }
        }

        public IEnumerator UnloadAssetsWait()
        {
            do
            {
                unloadNext = false;
                Resources.UnloadUnusedAssets();
                yield return new WaitForSeconds(waitTillNextUnload);
            } while (unloadNext);

            canUnload = true;
        }

        #endregion

        void OnDrawGizmosSelected()
        {
            if (sceneCollectionManagers == null)
                return;

            Vector3 size = Vector3.zero;
            Vector3 position = Vector3.zero;
            Vector3Int loadingRange = Vector3Int.zero;

            foreach (var manager in sceneCollectionManagers)
            {
                if (manager && manager.showDebug && manager.active)
                {
                    Gizmos.color = manager.color;
                    size = new Vector3(manager.xSize == 0 ? 2 : manager.xSize,
                                       manager.ySize == 0 ? 2 : manager.ySize,
                                       manager.zSize == 0 ? 2 : manager.zSize);

                    loadingRange = new Vector3Int(manager.xSplitIs ? manager.loadingRange.x : 0,
                                                  manager.ySplitIs ? manager.loadingRange.y : 0,
                                                  manager.zSplitIs ? manager.loadingRange.z : 0);

                    for (int x = -loadingRange.x + manager.xPos; x <= loadingRange.x + manager.xPos; x++)
                    {
                        for (int y = -loadingRange.y + manager.yPos; y <= loadingRange.y + manager.yPos; y++)
                        {
                            for (int z = -loadingRange.z + manager.zPos; z <= loadingRange.z + manager.zPos; z++)
                            {
                                // Skip drawing if inside the minimum loading range
                                if (manager.useLoadingRangeMin &&
                                    x - manager.xPos >= -manager.loadingRangeMin.x && x - manager.xPos <= manager.loadingRangeMin.x &&
                                    y - manager.yPos >= -manager.loadingRangeMin.y && y - manager.yPos <= manager.loadingRangeMin.y &&
                                    z - manager.zPos >= -manager.loadingRangeMin.z && z - manager.zPos <= manager.loadingRangeMin.z)
                                {
                                    continue;
                                }
                                else
                                {
                                    position = Vector3.Scale(new Vector3(x, y, z), size);
                                    if (!Application.isPlaying)
                                    {
                                        position -= Vector3.Scale(new Vector3(manager.xPos, manager.yPos, manager.zPos), size);
                                    }


                                    Gizmos.DrawWireCube(position + size * 0.5f + currentMove, size);
                                }
                            }
                        }
                    }

                    Gizmos.color = Color.green;
                    Vector3 originPosition = Application.isPlaying
                                             ? new Vector3(manager.xPos * size.x, manager.yPos * size.y, manager.zPos * size.z) + size * 0.5f + currentMove
                                             : size * 0.5f;

                    Gizmos.DrawWireCube(originPosition, size);
                }
            }
        }

#if AT_STREAMER2
        public override int GetTilesToLoad() 
        {
            return tilesToLoad;
        }

        public override int GetTilesLoaded()
        {
            return tilesLoaded;
        }

        public override float GetLoadingProgress()
        {
            return (tilesToLoad > 0) ? tilesLoaded / (float)tilesToLoad : 1;
        }
#endif
    }
}